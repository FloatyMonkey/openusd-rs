// This file is auto-generated by genschema.rs.
// Code added after the 'BEGIN CUSTOM CODE' marker will be preserved.

use crate::{declare_public_tokens, sdf, tf, usd};

declare_public_tokens!(Tokens, TOKENS, [
	face_vertex_counts: "faceVertexCounts",
	face_vertex_indices: "faceVertexIndices",
	normals: "normals",
	points: "points",
	purpose: "purpose",
	visibility: "visibility",
	xform_op_order: "xformOpOrder"
]);

#[repr(transparent)]
pub struct Imageable<'a>(usd::SchemaBase<'a>);

impl Imageable<'_> {
	pub fn define(stage: &usd::Stage, path: impl Into<sdf::Path>) -> Imageable {
		Imageable(usd::SchemaBase::new(stage.prim_at_path(path)))
	}

	pub fn visibility_attr(&self) -> usd::Attribute {
		self.prim().get_attribute(&TOKENS.visibility)
	}

	pub fn purpose_attr(&self) -> usd::Attribute {
		self.prim().get_attribute(&TOKENS.purpose)
	}
}

impl<'a> std::ops::Deref for Imageable<'a> {
	type Target = usd::SchemaBase<'a>;
	fn deref(&self) -> &Self::Target {
		unsafe { std::mem::transmute(self) }
	}
}

#[repr(transparent)]
pub struct Xformable<'a>(usd::SchemaBase<'a>);

impl Xformable<'_> {
	pub fn define(stage: &usd::Stage, path: impl Into<sdf::Path>) -> Xformable {
		Xformable(usd::SchemaBase::new(stage.prim_at_path(path)))
	}

	pub fn xform_op_order_attr(&self) -> usd::Attribute {
		self.prim().get_attribute(&TOKENS.xform_op_order)
	}
}

impl<'a> std::ops::Deref for Xformable<'a> {
	type Target = Imageable<'a>;
	fn deref(&self) -> &Self::Target {
		unsafe { std::mem::transmute(self) }
	}
}

#[repr(transparent)]
pub struct Boundable<'a>(usd::SchemaBase<'a>);

impl Boundable<'_> {
	pub fn define(stage: &usd::Stage, path: impl Into<sdf::Path>) -> Boundable {
		Boundable(usd::SchemaBase::new(stage.prim_at_path(path)))
	}
}

impl<'a> std::ops::Deref for Boundable<'a> {
	type Target = Xformable<'a>;
	fn deref(&self) -> &Self::Target {
		unsafe { std::mem::transmute(self) }
	}
}

#[repr(transparent)]
pub struct Gprim<'a>(usd::SchemaBase<'a>);

impl Gprim<'_> {
	pub fn define(stage: &usd::Stage, path: impl Into<sdf::Path>) -> Gprim {
		Gprim(usd::SchemaBase::new(stage.prim_at_path(path)))
	}
}

impl<'a> std::ops::Deref for Gprim<'a> {
	type Target = Boundable<'a>;
	fn deref(&self) -> &Self::Target {
		unsafe { std::mem::transmute(self) }
	}
}

#[repr(transparent)]
pub struct PointBased<'a>(usd::SchemaBase<'a>);

impl PointBased<'_> {
	pub fn define(stage: &usd::Stage, path: impl Into<sdf::Path>) -> PointBased {
		PointBased(usd::SchemaBase::new(stage.prim_at_path(path)))
	}

	pub fn points_attr(&self) -> usd::Attribute {
		self.prim().get_attribute(&TOKENS.points)
	}

	pub fn normals_attr(&self) -> usd::Attribute {
		self.prim().get_attribute(&TOKENS.normals)
	}
}

impl<'a> std::ops::Deref for PointBased<'a> {
	type Target = Gprim<'a>;
	fn deref(&self) -> &Self::Target {
		unsafe { std::mem::transmute(self) }
	}
}

#[repr(transparent)]
pub struct Mesh<'a>(usd::SchemaBase<'a>);

impl Mesh<'_> {
	pub fn define(stage: &usd::Stage, path: impl Into<sdf::Path>) -> Mesh {
		Mesh(usd::SchemaBase::new(stage.prim_at_path(path)))
	}

	pub fn face_vertex_indices_attr(&self) -> usd::Attribute {
		self.prim().get_attribute(&TOKENS.face_vertex_indices)
	}

	pub fn face_vertex_counts_attr(&self) -> usd::Attribute {
		self.prim().get_attribute(&TOKENS.face_vertex_counts)
	}
}

impl<'a> std::ops::Deref for Mesh<'a> {
	type Target = PointBased<'a>;
	fn deref(&self) -> &Self::Target {
		unsafe { std::mem::transmute(self) }
	}
}

// --- (BEGIN CUSTOM CODE) ---

pub fn triangulate(mesh: &Mesh) -> Vec<i32> {
	let face_vertex_counts = mesh.face_vertex_counts_attr().get::<Vec<i32>>();
	let face_vertex_indices = mesh.face_vertex_indices_attr().get::<Vec<i32>>();

	let mut indices = vec![];

	// Simple triangulation with triangle fan
	let mut index = 0;
	for &count in &face_vertex_counts {
		for i in 0..(count - 2) as usize {
			indices.push(face_vertex_indices[index]);
			indices.push(face_vertex_indices[index + i + 1]);
			indices.push(face_vertex_indices[index + i + 2]);
		}
		index += count as usize;
	}

	indices
}
