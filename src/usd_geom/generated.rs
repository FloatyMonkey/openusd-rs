// This file is auto-generated by genschema.rs.
// Code added after the 'BEGIN CUSTOM CODE' marker will be preserved.

use crate::{declare_public_tokens, sdf, tf, usd};

declare_public_tokens!(Tokens, TOKENS, [
	accelerations: "accelerations",
	angular_velocities: "angularVelocities",
	face_vertex_counts: "faceVertexCounts",
	face_vertex_indices: "faceVertexIndices",
	ids: "ids",
	invisible_ids: "invisibleIds",
	normals: "normals",
	orientations: "orientations",
	orientationsf: "orientationsf",
	points: "points",
	positions: "positions",
	proto_indices: "protoIndices",
	prototypes: "prototypes",
	purpose: "purpose",
	scales: "scales",
	velocities: "velocities",
	visibility: "visibility",
	xform_op_order: "xformOpOrder"
]);

#[repr(transparent)]
pub struct Imageable<'a>(usd::SchemaBase<'a>);

impl Imageable<'_> {
	pub fn define(stage: &usd::Stage, path: impl Into<sdf::Path>) -> Imageable<'_> {
		Imageable(usd::SchemaBase::new(stage.prim_at_path(path)))
	}

	pub fn visibility_attr(&self) -> usd::Attribute<'_> {
		self.prim().attribute(&TOKENS.visibility)
	}

	pub fn purpose_attr(&self) -> usd::Attribute<'_> {
		self.prim().attribute(&TOKENS.purpose)
	}

}

impl<'a> std::ops::Deref for Imageable<'a> {
	type Target = usd::SchemaBase<'a>;
	fn deref(&self) -> &Self::Target {
		unsafe { std::mem::transmute(self) }
	}
}

#[repr(transparent)]
pub struct Xformable<'a>(usd::SchemaBase<'a>);

impl Xformable<'_> {
	pub fn define(stage: &usd::Stage, path: impl Into<sdf::Path>) -> Xformable<'_> {
		Xformable(usd::SchemaBase::new(stage.prim_at_path(path)))
	}

	pub fn xform_op_order_attr(&self) -> usd::Attribute<'_> {
		self.prim().attribute(&TOKENS.xform_op_order)
	}

}

impl<'a> std::ops::Deref for Xformable<'a> {
	type Target = Imageable<'a>;
	fn deref(&self) -> &Self::Target {
		unsafe { std::mem::transmute(self) }
	}
}

#[repr(transparent)]
pub struct Boundable<'a>(usd::SchemaBase<'a>);

impl Boundable<'_> {
	pub fn define(stage: &usd::Stage, path: impl Into<sdf::Path>) -> Boundable<'_> {
		Boundable(usd::SchemaBase::new(stage.prim_at_path(path)))
	}

}

impl<'a> std::ops::Deref for Boundable<'a> {
	type Target = Xformable<'a>;
	fn deref(&self) -> &Self::Target {
		unsafe { std::mem::transmute(self) }
	}
}

#[repr(transparent)]
pub struct Gprim<'a>(usd::SchemaBase<'a>);

impl Gprim<'_> {
	pub fn define(stage: &usd::Stage, path: impl Into<sdf::Path>) -> Gprim<'_> {
		Gprim(usd::SchemaBase::new(stage.prim_at_path(path)))
	}

}

impl<'a> std::ops::Deref for Gprim<'a> {
	type Target = Boundable<'a>;
	fn deref(&self) -> &Self::Target {
		unsafe { std::mem::transmute(self) }
	}
}

#[repr(transparent)]
pub struct PointBased<'a>(usd::SchemaBase<'a>);

impl PointBased<'_> {
    pub fn define(stage: &usd::Stage, path: impl Into<sdf::Path>) -> PointBased<'_> {
        PointBased(usd::SchemaBase::new(stage.prim_at_path(path)))
    }

    // --- points ---
    pub fn has_points_attr(&self) -> bool {
        self.prim().has_attribute(&TOKENS.points)
    }
    pub fn points_attr(&self) -> usd::Attribute<'_> {
        self.prim().attribute(&TOKENS.points)
    }

    // --- normals ---
    pub fn has_normals_attr(&self) -> bool {
        self.prim().has_attribute(&TOKENS.normals)
    }
    pub fn normals_attr(&self) -> usd::Attribute<'_> {
        self.prim().attribute(&TOKENS.normals)
    }

    
    // --- primvars ---
    pub fn has_primvar(&self, name: &usd::Token) -> bool {
        let token = usd::Token::new(format!("primvars:{}", name.as_str()));
        self.prim().has_attribute(&token)
    }

    pub fn primvar(&self, name: &usd::Token) -> usd::Attribute<'_> {
        let token = usd::Token::new(format!("primvars:{}", name.as_str()));
        self.prim().attribute(&token)
    }
}


impl<'a> std::ops::Deref for PointBased<'a> {
	type Target = Gprim<'a>;
	fn deref(&self) -> &Self::Target {
		unsafe { std::mem::transmute(self) }
	}
}

#[repr(transparent)]
pub struct Mesh<'a>(usd::SchemaBase<'a>);

impl Mesh<'_> {
    pub fn define(stage: &usd::Stage, path: impl Into<sdf::Path>) -> Mesh<'_> {
        Mesh(usd::SchemaBase::new(stage.prim_at_path(path)))
    }

    // --- face vertex indices ---
    pub fn has_face_vertex_indices_attr(&self) -> bool {
        self.prim().has_attribute(&TOKENS.face_vertex_indices)
    }
    pub fn face_vertex_indices_attr(&self) -> usd::Attribute<'_> {
        self.prim().attribute(&TOKENS.face_vertex_indices)
    }

    // --- face vertex counts ---
    pub fn has_face_vertex_counts_attr(&self) -> bool {
        self.prim().has_attribute(&TOKENS.face_vertex_counts)
    }
    pub fn face_vertex_counts_attr(&self) -> usd::Attribute<'_> {
        self.prim().attribute(&TOKENS.face_vertex_counts)
    }
}

impl<'a> std::ops::Deref for Mesh<'a> {
	type Target = PointBased<'a>;
	fn deref(&self) -> &Self::Target {
		unsafe { std::mem::transmute(self) }
	}
}

#[repr(transparent)]
pub struct PointInstancer<'a>(usd::SchemaBase<'a>);

impl PointInstancer<'_> {
	pub fn define(stage: &usd::Stage, path: impl Into<sdf::Path>) -> PointInstancer<'_> {
		PointInstancer(usd::SchemaBase::new(stage.prim_at_path(path)))
	}

	pub fn prototypes_rel(&self) -> usd::Relationship<'_> {
		self.prim().relationship(&TOKENS.prototypes)
	}

	pub fn proto_indices_attr(&self) -> usd::Attribute<'_> {
		self.prim().attribute(&TOKENS.proto_indices)
	}

	pub fn ids_attr(&self) -> usd::Attribute<'_> {
		self.prim().attribute(&TOKENS.ids)
	}

	pub fn positions_attr(&self) -> usd::Attribute<'_> {
		self.prim().attribute(&TOKENS.positions)
	}

	pub fn orientations_attr(&self) -> usd::Attribute<'_> {
		self.prim().attribute(&TOKENS.orientations)
	}

	pub fn orientationsf_attr(&self) -> usd::Attribute<'_> {
		self.prim().attribute(&TOKENS.orientationsf)
	}

	pub fn scales_attr(&self) -> usd::Attribute<'_> {
		self.prim().attribute(&TOKENS.scales)
	}

	pub fn velocities_attr(&self) -> usd::Attribute<'_> {
		self.prim().attribute(&TOKENS.velocities)
	}

	pub fn accelerations_attr(&self) -> usd::Attribute<'_> {
		self.prim().attribute(&TOKENS.accelerations)
	}

	pub fn angular_velocities_attr(&self) -> usd::Attribute<'_> {
		self.prim().attribute(&TOKENS.angular_velocities)
	}

	pub fn invisible_ids_attr(&self) -> usd::Attribute<'_> {
		self.prim().attribute(&TOKENS.invisible_ids)
	}

}

impl<'a> std::ops::Deref for PointInstancer<'a> {
	type Target = Boundable<'a>;
	fn deref(&self) -> &Self::Target {
		unsafe { std::mem::transmute(self) }
	}
}

// --- (BEGIN CUSTOM CODE) ---

pub fn triangulate(mesh: &Mesh) -> Vec<i32> {
	use crate::vt;

	let face_vertex_counts = mesh.face_vertex_counts_attr().get::<vt::Array<i32>>();
	let face_vertex_indices = mesh.face_vertex_indices_attr().get::<vt::Array<i32>>();

	let mut indices = vec![];

	// Simple triangulation with triangle fan
	let mut index = 0;
	for &count in &face_vertex_counts {
		for i in 0..(count - 2) as usize {
			indices.push(face_vertex_indices[index]);
			indices.push(face_vertex_indices[index + i + 1]);
			indices.push(face_vertex_indices[index + i + 2]);
		}
		index += count as usize;
	}

	indices
}
