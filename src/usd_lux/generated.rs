// This file is auto-generated by genschema.rs.
// Code added after the 'BEGIN CUSTOM CODE' marker will be preserved.

use crate::{declare_public_tokens, sdf, tf, usd};

declare_public_tokens!(Tokens, TOKENS, [
	guide_radius: "guideRadius",
	inputs_color: "inputs:color",
	inputs_color_temperature: "inputs:colorTemperature",
	inputs_diffuse: "inputs:diffuse",
	inputs_enable_color_temperature: "inputs:enableColorTemperature",
	inputs_exposure: "inputs:exposure",
	inputs_height: "inputs:height",
	inputs_intensity: "inputs:intensity",
	inputs_normalize: "inputs:normalize",
	inputs_radius: "inputs:radius",
	inputs_specular: "inputs:specular",
	inputs_texture_file: "inputs:texture:file",
	inputs_texture_format: "inputs:texture:format",
	inputs_width: "inputs:width",
	portals: "portals",
	treat_as_point: "treatAsPoint"
]);

/// API schema that imparts the quality of being a light onto a prim.
#[repr(transparent)]
pub struct LightAPI<'a>(usd::SchemaBase<'a>);

impl LightAPI<'_> {
	pub fn define(stage: &usd::Stage, path: impl Into<sdf::Path>) -> LightAPI {
		LightAPI(usd::SchemaBase::new(stage.prim_at_path(path)))
	}

	/// Scales the brightness of the light linearly.
	pub fn intensity_attr(&self) -> usd::Attribute {
		self.prim().attribute(&TOKENS.inputs_intensity)
	}

	/// Scales the brightness of the light exponentially as a power
	/// of 2 (similar to an F-stop control over exposure). The result
	/// is multiplied against the intensity.
	pub fn exposure_attr(&self) -> usd::Attribute {
		self.prim().attribute(&TOKENS.inputs_exposure)
	}

	/// A multiplier for the effect of this light on the diffuse
	/// response of materials. This is a non-physical control.
	pub fn diffuse_attr(&self) -> usd::Attribute {
		self.prim().attribute(&TOKENS.inputs_diffuse)
	}

	/// A multiplier for the effect of this light on the specular
	/// response of materials. This is a non-physical control.
	pub fn specular_attr(&self) -> usd::Attribute {
		self.prim().attribute(&TOKENS.inputs_specular)
	}

	/// Normalizes the emission such that the power of the light
	/// remains constant while altering the size of the light, by dividing the
	/// luminance by the world-space surface area of the light.
	/// 
	/// This makes it easier to independently adjust the brightness and size
	/// of the light, by causing the total illumination provided by a light to
	/// not vary with the area or angular size of the light.
	pub fn normalize_attr(&self) -> usd::Attribute {
		self.prim().attribute(&TOKENS.inputs_normalize)
	}

	/// The color of emitted light, in the rendering color space.
	/// This color is just multiplied with the emission.
	pub fn color_attr(&self) -> usd::Attribute {
		self.prim().attribute(&TOKENS.inputs_color)
	}

	/// Enables using colorTemperature.
	pub fn enable_color_temperature_attr(&self) -> usd::Attribute {
		self.prim().attribute(&TOKENS.inputs_enable_color_temperature)
	}

	/// Color temperature, in degrees Kelvin, representing the
	/// white point.  The default is a common white point, D65.  Lower
	/// values are warmer and higher values are cooler.  The valid range
	/// is from 1000 to 10000. Only takes effect when
	/// enableColorTemperature is set to true.
	pub fn color_temperature_attr(&self) -> usd::Attribute {
		self.prim().attribute(&TOKENS.inputs_color_temperature)
	}

}

impl<'a> std::ops::Deref for LightAPI<'a> {
	type Target = usd::SchemaBase<'a>;
	fn deref(&self) -> &Self::Target {
		unsafe { std::mem::transmute(self) }
	}
}

/// Base class for intrinsic lights that are boundable.
#[repr(transparent)]
pub struct BoundableLightBase<'a>(usd::SchemaBase<'a>);

impl BoundableLightBase<'_> {
	pub fn define(stage: &usd::Stage, path: impl Into<sdf::Path>) -> BoundableLightBase {
		BoundableLightBase(usd::SchemaBase::new(stage.prim_at_path(path)))
	}

}

impl<'a> std::ops::Deref for BoundableLightBase<'a> {
	type Target = LightAPI<'a>;
	fn deref(&self) -> &Self::Target {
		unsafe { std::mem::transmute(self) }
	}
}

/// Base class for intrinsic lights that are not boundable.
#[repr(transparent)]
pub struct NonboundableLightBase<'a>(usd::SchemaBase<'a>);

impl NonboundableLightBase<'_> {
	pub fn define(stage: &usd::Stage, path: impl Into<sdf::Path>) -> NonboundableLightBase {
		NonboundableLightBase(usd::SchemaBase::new(stage.prim_at_path(path)))
	}

}

impl<'a> std::ops::Deref for NonboundableLightBase<'a> {
	type Target = LightAPI<'a>;
	fn deref(&self) -> &Self::Target {
		unsafe { std::mem::transmute(self) }
	}
}

/// Light emitted from one side of a circular disk.
/// The disk is centered in the XY plane and emits light along the -Z axis.
#[repr(transparent)]
pub struct DiskLight<'a>(usd::SchemaBase<'a>);

impl DiskLight<'_> {
	pub fn define(stage: &usd::Stage, path: impl Into<sdf::Path>) -> DiskLight {
		DiskLight(usd::SchemaBase::new(stage.prim_at_path(path)))
	}

	/// Radius of the disk.
	pub fn radius_attr(&self) -> usd::Attribute {
		self.prim().attribute(&TOKENS.inputs_radius)
	}

}

impl<'a> std::ops::Deref for DiskLight<'a> {
	type Target = BoundableLightBase<'a>;
	fn deref(&self) -> &Self::Target {
		unsafe { std::mem::transmute(self) }
	}
}

/// Light emitted from one side of a rectangle.
/// The rectangle is centered in the XY plane and emits light along the -Z axis.
/// The rectangle is 1 unit in length in the X and Y axis.  In the default 
/// position, a texture file's min coordinates should be at (+X, +Y) and 
/// max coordinates at (-X, -Y).
#[repr(transparent)]
pub struct RectLight<'a>(usd::SchemaBase<'a>);

impl RectLight<'_> {
	pub fn define(stage: &usd::Stage, path: impl Into<sdf::Path>) -> RectLight {
		RectLight(usd::SchemaBase::new(stage.prim_at_path(path)))
	}

	/// Width of the rectangle, in the local X axis.
	pub fn width_attr(&self) -> usd::Attribute {
		self.prim().attribute(&TOKENS.inputs_width)
	}

	/// Height of the rectangle, in the local Y axis.
	pub fn height_attr(&self) -> usd::Attribute {
		self.prim().attribute(&TOKENS.inputs_height)
	}

	/// A color texture to use on the rectangle.
	pub fn texture_file_attr(&self) -> usd::Attribute {
		self.prim().attribute(&TOKENS.inputs_texture_file)
	}

}

impl<'a> std::ops::Deref for RectLight<'a> {
	type Target = BoundableLightBase<'a>;
	fn deref(&self) -> &Self::Target {
		unsafe { std::mem::transmute(self) }
	}
}

/// Light emitted outward from a sphere.
#[repr(transparent)]
pub struct SphereLight<'a>(usd::SchemaBase<'a>);

impl SphereLight<'_> {
	pub fn define(stage: &usd::Stage, path: impl Into<sdf::Path>) -> SphereLight {
		SphereLight(usd::SchemaBase::new(stage.prim_at_path(path)))
	}

	/// Radius of the sphere.
	pub fn radius_attr(&self) -> usd::Attribute {
		self.prim().attribute(&TOKENS.inputs_radius)
	}

	/// A hint that this light can be treated as a 'point'
	/// light (effectively, a zero-radius sphere) by renderers that
	/// benefit from non-area lighting. Renderers that only support
	/// area lights can disregard this.
	pub fn treat_as_point_attr(&self) -> usd::Attribute {
		self.prim().attribute(&TOKENS.treat_as_point)
	}

}

impl<'a> std::ops::Deref for SphereLight<'a> {
	type Target = BoundableLightBase<'a>;
	fn deref(&self) -> &Self::Target {
		unsafe { std::mem::transmute(self) }
	}
}

/// Light emitted inward from a distant external environment,
/// such as a sky or IBL light probe.
/// 
/// In this version of the dome light, the dome's default orientation is such
/// that its top pole is aligned with the world's +Y axis. This adheres to the
/// OpenEXR specification for latlong environment maps.
#[repr(transparent)]
pub struct DomeLight<'a>(usd::SchemaBase<'a>);

impl DomeLight<'_> {
	pub fn define(stage: &usd::Stage, path: impl Into<sdf::Path>) -> DomeLight {
		DomeLight(usd::SchemaBase::new(stage.prim_at_path(path)))
	}

	/// A color texture to use on the dome, such as an HDR (high
	/// dynamic range) texture intended for IBL (image based lighting).
	pub fn texture_file_attr(&self) -> usd::Attribute {
		self.prim().attribute(&TOKENS.inputs_texture_file)
	}

	/// Specifies the parameterization of the color map file.
	/// Valid values are:
	/// - automatic: Tries to determine the layout from the file itself.
	/// For example, Renderman texture files embed an explicit
	/// parameterization.
	/// - latlong: Latitude as X, longitude as Y.
	/// - mirroredBall: An image of the environment reflected in a
	/// sphere, using an implicitly orthogonal projection.
	/// - angular: Similar to mirroredBall but the radial dimension
	/// is mapped linearly to the angle, providing better sampling
	/// at the edges.
	/// - cubeMapVerticalCross: A cube map with faces laid out as a
	/// vertical cross.
	pub fn texture_format_attr(&self) -> usd::Attribute {
		self.prim().attribute(&TOKENS.inputs_texture_format)
	}

	/// Optional portals to guide light sampling.
	pub fn portals_rel(&self) -> usd::Relationship {
		self.prim().relationship(&TOKENS.portals)
	}

	/// The radius of guide geometry to use to visualize the dome light.
	/// The default is 1 km for scenes whose metersPerUnit is the USD default of
	/// 0.01 (i.e., 1 world unit is 1 cm).
	pub fn guide_radius_attr(&self) -> usd::Attribute {
		self.prim().attribute(&TOKENS.guide_radius)
	}

}

impl<'a> std::ops::Deref for DomeLight<'a> {
	type Target = NonboundableLightBase<'a>;
	fn deref(&self) -> &Self::Target {
		unsafe { std::mem::transmute(self) }
	}
}

// --- (BEGIN CUSTOM CODE) ---
