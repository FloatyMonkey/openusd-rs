// This file is auto-generated by genschema.rs.
// Code added after the 'BEGIN CUSTOM CODE' marker will be preserved.

use crate::{declare_public_tokens, sdf, tf, usd};

declare_public_tokens!(Tokens, TOKENS, [
	bind_transforms: "bindTransforms",
	blend_shape_weights: "blendShapeWeights",
	blend_shapes: "blendShapes",
	joint_names: "jointNames",
	joints: "joints",
	normal_offsets: "normalOffsets",
	offsets: "offsets",
	point_indices: "pointIndices",
	primvars_skel_geom_bind_transform: "primvars:skel:geomBindTransform",
	primvars_skel_joint_indices: "primvars:skel:jointIndices",
	primvars_skel_joint_weights: "primvars:skel:jointWeights",
	primvars_skel_skinning_method: "primvars:skel:skinningMethod",
	rest_transforms: "restTransforms",
	rotations: "rotations",
	scales: "scales",
	skel_animation_source: "skel:animationSource",
	skel_blend_shape_targets: "skel:blendShapeTargets",
	skel_blend_shapes: "skel:blendShapes",
	skel_joints: "skel:joints",
	skel_skeleton: "skel:skeleton",
	translations: "translations"
]);

/// Boundable prim type used to identify a scope beneath which
/// skeletally-posed primitives are defined.
/// 
/// A SkelRoot must be defined at or above a skinned primitive for any skinning
/// behaviors in UsdSkel.
#[repr(transparent)]
pub struct SkelRoot<'a>(usd::SchemaBase<'a>);

impl SkelRoot<'_> {
	pub fn define(stage: &usd::Stage, path: impl Into<sdf::Path>) -> SkelRoot {
		SkelRoot(usd::SchemaBase::new(stage.prim_at_path(path)))
	}

}

impl<'a> std::ops::Deref for SkelRoot<'a> {
	type Target = usd::SchemaBase<'a>;
	fn deref(&self) -> &Self::Target {
		unsafe { std::mem::transmute(self) }
	}
}

/// Describes a skeleton.
#[repr(transparent)]
pub struct Skeleton<'a>(usd::SchemaBase<'a>);

impl Skeleton<'_> {
	pub fn define(stage: &usd::Stage, path: impl Into<sdf::Path>) -> Skeleton {
		Skeleton(usd::SchemaBase::new(stage.prim_at_path(path)))
	}

	/// An array of path tokens identifying the set of joints that make
	/// up the skeleton, and their order. Each token in the array must be valid
	/// when parsed as an SdfPath. The parent-child relationships of the
	/// corresponding paths determine the parent-child relationships of each
	/// joint. It is not required that the name at the end of each path be
	/// unique, but rather only that the paths themselves be unique.
	pub fn joints_attr(&self) -> usd::Attribute {
		self.prim().attribute(&TOKENS.joints)
	}

	/// If authored, provides a unique name per joint. This may be
	/// optionally set to provide better names when translating to DCC apps 
	/// that require unique joint names.
	pub fn joint_names_attr(&self) -> usd::Attribute {
		self.prim().attribute(&TOKENS.joint_names)
	}

	/// Specifies the bind-pose transforms of each joint in
	/// **world space**, in the ordering imposed by *joints*.
	pub fn bind_transforms_attr(&self) -> usd::Attribute {
		self.prim().attribute(&TOKENS.bind_transforms)
	}

	/// Specifies the rest-pose transforms of each joint in
	/// **local space**, in the ordering imposed by *joints*. This provides
	/// fallback values for joint transforms when a Skeleton either has no
	/// bound animation source, or when that animation source only contains
	/// animation for a subset of a Skeleton's joints.
	pub fn rest_transforms_attr(&self) -> usd::Attribute {
		self.prim().attribute(&TOKENS.rest_transforms)
	}

}

impl<'a> std::ops::Deref for Skeleton<'a> {
	type Target = usd::SchemaBase<'a>;
	fn deref(&self) -> &Self::Target {
		unsafe { std::mem::transmute(self) }
	}
}

/// Describes a skel animation, where joint animation is stored in a
/// vectorized form.
#[repr(transparent)]
pub struct SkelAnimation<'a>(usd::SchemaBase<'a>);

impl SkelAnimation<'_> {
	pub fn define(stage: &usd::Stage, path: impl Into<sdf::Path>) -> SkelAnimation {
		SkelAnimation(usd::SchemaBase::new(stage.prim_at_path(path)))
	}

	/// Array of tokens identifying which joints this animation's
	/// data applies to. The tokens for joints correspond to the tokens of
	/// Skeleton primitives. The order of the joints as listed here may
	/// vary from the order of joints on the Skeleton itself.
	pub fn joints_attr(&self) -> usd::Attribute {
		self.prim().attribute(&TOKENS.joints)
	}

	/// Joint-local translations of all affected joints. Array length 
	/// should match the size of the *joints* attribute.
	pub fn translations_attr(&self) -> usd::Attribute {
		self.prim().attribute(&TOKENS.translations)
	}

	/// Joint-local unit quaternion rotations of all affected joints, 
	/// in 32-bit precision. Array length should match the size of the 
	/// *joints* attribute.
	pub fn rotations_attr(&self) -> usd::Attribute {
		self.prim().attribute(&TOKENS.rotations)
	}

	/// Joint-local scales of all affected joints, in
	/// 16 bit precision. Array length should match the size of the *joints* 
	/// attribute.
	pub fn scales_attr(&self) -> usd::Attribute {
		self.prim().attribute(&TOKENS.scales)
	}

	/// Array of tokens identifying which blend shapes this
	/// animation's data applies to. The tokens for blendShapes correspond to
	/// the tokens set in the *skel:blendShapes* binding property of the
	/// UsdSkelBindingAPI. Note that blendShapes does not accept time-sampled
	/// values.
	pub fn blend_shapes_attr(&self) -> usd::Attribute {
		self.prim().attribute(&TOKENS.blend_shapes)
	}

	/// Array of weight values for each blend shape. Each weight value
	/// is associated with the corresponding blend shape identified within the
	/// *blendShapes* token array, and therefore must have the same length as
	/// *blendShapes.
	pub fn blend_shape_weights_attr(&self) -> usd::Attribute {
		self.prim().attribute(&TOKENS.blend_shape_weights)
	}

}

impl<'a> std::ops::Deref for SkelAnimation<'a> {
	type Target = usd::SchemaBase<'a>;
	fn deref(&self) -> &Self::Target {
		unsafe { std::mem::transmute(self) }
	}
}

/// Provides API for authoring and extracting all the skinning-related
/// data that lives in the "geometry hierarchy" of prims and models that want
/// to be skeletally deformed.
#[repr(transparent)]
pub struct SkelBindingAPI<'a>(usd::SchemaBase<'a>);

impl SkelBindingAPI<'_> {
	pub fn define(stage: &usd::Stage, path: impl Into<sdf::Path>) -> SkelBindingAPI {
		SkelBindingAPI(usd::SchemaBase::new(stage.prim_at_path(path)))
	}

	/// Animation source to be bound to Skeleton primitives at or
	/// beneath the location at which this property is defined.
	pub fn animation_source_rel(&self) -> usd::Relationship {
		self.prim().relationship(&TOKENS.skel_animation_source)
	}

	/// Skeleton to be bound to this prim and its descendents that
	/// possess a mapping and weighting to the joints of the identified
	/// Skeleton.
	pub fn skeleton_rel(&self) -> usd::Relationship {
		self.prim().relationship(&TOKENS.skel_skeleton)
	}

	/// The skinningMethod specifies the skinning method for the prim.
	pub fn skinning_method_attr(&self) -> usd::Attribute {
		self.prim().attribute(&TOKENS.primvars_skel_skinning_method)
	}

	/// Encodes the bind-time world space transforms of the prim.
	/// If the transform is identical for a group of gprims that share a common
	/// ancestor, the transform may be authored on the ancestor, to "inherit"
	/// down to all the leaf gprims. If this transform is unset, an identity
	/// transform is used instead.
	pub fn geom_bind_transform_attr(&self) -> usd::Attribute {
		self.prim().attribute(&TOKENS.primvars_skel_geom_bind_transform)
	}

	/// An (optional) array of tokens defining the list of
	/// joints to which jointIndices apply. If not defined, jointIndices applies
	/// to the ordered list of joints defined in the bound Skeleton's *joints*
	/// attribute. If undefined on a primitive, the primitive inherits the 
	/// value of the nearest ancestor prim, if any.
	pub fn joints_attr(&self) -> usd::Attribute {
		self.prim().attribute(&TOKENS.skel_joints)
	}

	/// Indices into the *joints* attribute of the closest
	/// (in namespace) bound Skeleton that affect each point of a PointBased
	/// gprim. The primvar can have either *constant* or *vertex* interpolation.
	/// This primvar's *elementSize* will determine how many joint influences
	/// apply to each point. Indices must point be valid. Null influences should
	/// be defined by setting values in jointWeights to zero.
	/// See UsdGeomPrimvar for more information on interpolation and
	/// elementSize.
	pub fn joint_indices_attr(&self) -> usd::Attribute {
		self.prim().attribute(&TOKENS.primvars_skel_joint_indices)
	}

	/// Weights for the joints that affect each point of a PointBased
	/// gprim. The primvar can have either *constant* or *vertex* interpolation.
	/// This primvar's *elementSize* will determine how many joints influences
	/// apply to each point. The length, interpolation, and elementSize of
	/// *jointWeights* must match that of *jointIndices*. See UsdGeomPrimvar
	/// for more information on interpolation and elementSize.
	pub fn joint_weights_attr(&self) -> usd::Attribute {
		self.prim().attribute(&TOKENS.primvars_skel_joint_weights)
	}

	/// An array of tokens defining the order onto which blend shape
	/// weights from an animation source map onto the *skel:blendShapeTargets*
	/// rel of a binding site. If authored, the number of elements must be equal
	/// to the number of targets in the _blendShapeTargets_ rel. This property
	/// is not inherited hierarchically, and is expected to be authored directly
	/// on the skinnable primitive to which the blend shapes apply.
	pub fn blend_shapes_attr(&self) -> usd::Attribute {
		self.prim().attribute(&TOKENS.skel_blend_shapes)
	}

	/// Ordered list of all target blend shapes. This property is not
	/// inherited hierarchically, and is expected to be authored directly on
	/// the skinnable primitive to which the the blend shapes apply.
	pub fn blend_shape_targets_rel(&self) -> usd::Relationship {
		self.prim().relationship(&TOKENS.skel_blend_shape_targets)
	}

}

impl<'a> std::ops::Deref for SkelBindingAPI<'a> {
	type Target = usd::SchemaBase<'a>;
	fn deref(&self) -> &Self::Target {
		unsafe { std::mem::transmute(self) }
	}
}

/// Describes a target blend shape, possibly containing inbetween
/// shapes.
#[repr(transparent)]
pub struct BlendShape<'a>(usd::SchemaBase<'a>);

impl BlendShape<'_> {
	pub fn define(stage: &usd::Stage, path: impl Into<sdf::Path>) -> BlendShape {
		BlendShape(usd::SchemaBase::new(stage.prim_at_path(path)))
	}

	/// **Required property**. Position offsets which, when added to the
	/// base pose, provides the target shape.
	pub fn offsets_attr(&self) -> usd::Attribute {
		self.prim().attribute(&TOKENS.offsets)
	}

	/// **Required property**. Normal offsets which, when added to the
	/// base pose, provides the normals of the target shape.
	pub fn normal_offsets_attr(&self) -> usd::Attribute {
		self.prim().attribute(&TOKENS.normal_offsets)
	}

	/// **Optional property**. Indices into the original mesh that
	/// correspond to the values in *offsets* and of any inbetween shapes. If
	/// authored, the number of elements must be equal to the number of elements
	/// in the *offsets* array.
	pub fn point_indices_attr(&self) -> usd::Attribute {
		self.prim().attribute(&TOKENS.point_indices)
	}

}

impl<'a> std::ops::Deref for BlendShape<'a> {
	type Target = usd::SchemaBase<'a>;
	fn deref(&self) -> &Self::Target {
		unsafe { std::mem::transmute(self) }
	}
}

// --- (BEGIN CUSTOM CODE) ---
